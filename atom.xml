<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天才教授</title>
  
  <subtitle>好好学习 天天向上</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-07T02:48:57.232Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>giftedProfessor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/posts/0.html"/>
    <id>http://example.com/posts/0.html</id>
    <published>2022-11-07T02:45:57.109Z</published>
    <updated>2022-11-07T02:48:57.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h3><p>![image-20221102152902371](&#x2F;Users&#x2F;tiancaijiaoshou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221102152902371.png)</p><p>当我们输入一串 <code>url</code> 的时候，浏览器首先会进行 <code>DNS</code> 解析，将其转换为一串 ip 地址，之后浏览器会根据这一串ip地址找到这台服务器，从而接收到一个 <strong>html文件</strong>，至于一些 css，js 等资源，会随着浏览器解析 html 文件的时候逐步向服务器发送请求，下载下来</p><h4 id="1⃣️浏览器内核"><a href="#1⃣️浏览器内核" class="headerlink" title="1⃣️浏览器内核"></a>1⃣️浏览器内核</h4><p>主要知道有一个 <strong>Blink</strong> 就可以啦</p><p>其实浏览器引擎就是 <strong>排版引擎(layout engine)、页面渲染引擎…..</strong></p><p><img src="https://wx2.sinaimg.cn/mw2000/0074C7s5gy1h7rnfub324j31ty0ucn44.jpg" alt="image-20221102180247406"></p><h4 id="2⃣️Js引擎"><a href="#2⃣️Js引擎" class="headerlink" title="2⃣️Js引擎"></a>2⃣️Js引擎</h4><p><strong>高级编程语言都是需要转化为最终的机器指令执行的</strong>  javascript引擎 其实就是将 javaScript 代码翻译成 CPU指令（0100101001001）</p><p>Js引擎其实分为 <strong>WebCore 和 JavaScriptCore</strong> 前者用于 <strong>HTML解析、布局、渲染等工作</strong>，后者负责<strong>解析、执行js代码</strong></p><h4 id="3⃣️V8引擎的架构"><a href="#3⃣️V8引擎的架构" class="headerlink" title="3⃣️V8引擎的架构"></a>3⃣️V8引擎的架构</h4><ul><li><strong>什么是V8引擎？？？</strong><ul><li>v8引擎其实就是一个 <code>JaveScript</code> 引擎</li><li>v8引擎由 C++ 编写 目前用于 Chrome 和 Node.js</li><li>V8引擎的作用如下</li></ul></li></ul><p><img src="https://wx3.sinaimg.cn/mw2000/0074C7s5gy1h7rnfukvl0j31qi0eu42y.jpg" alt="image-20221102175426228"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中parser的作用就是进行词法分析⬇️</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;why&quot;</span> </span><br><span class="line"><span class="comment">//词法分析会将上面的代码变为一个 tokens数组⬇️</span></span><br><span class="line"><span class="attr">tokens</span>: [&#123;<span class="attr">type</span>: <span class="string">&quot;keyword&quot;</span>, <span class="attr">value</span>: <span class="string">&quot;const&quot;</span>&#125;, &#123;<span class="attr">type</span>: <span class="string">&quot;identifier&quot;</span>, <span class="attr">value</span>: <span class="string">&quot;name&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><p>然后就是<strong>语法分析</strong> 将代码转化为 AST 抽象语法树 转化为 抽象语法树 的原因是 <strong>抽象语法树的代码是树状结构，并且抽象语法树中的关键字较为固定 这样有助于 v8 引擎对于 js 代码的解析</strong>  </p><p><img src="https://wx3.sinaimg.cn/mw2000/0074C7s5gy1h7rnfsma2cj31rk0zk12o.jpg" alt="image-20221102161917250"></p><blockquote><p>例如 babal 的工作原理就是 ts code &#x3D;&#x3D;&gt; AST &#x3D;&#x3D;&gt; new AST &#x3D;&#x3D;&gt; generate code &#x3D;&#x3D;&gt; js code</p><p>​vue template:    template &#x3D;&#x3D;&gt; AST &#x3D;&#x3D;&gt; document.createVnode &#x3D;&#x3D;&gt; js code</p></blockquote><ul><li>**iginition **</li></ul><p><code>Ignition</code>是一个解释器，可以将 AST 抽象语法树转换为 <code>bytecode</code></p><p>将代码先转换为字节码之后再转换为机器码的原因是 js 代码可能会跑在不同的系统中 -&gt; macod window linux，而在不同的环境中就会有不同的<code>CPU</code>，不同的<code>CPU</code>的架构是不同的，执行相同操作的指令是不同的，而字节码是跨平台的，不管是在什么平台，最终都可以转化为 <strong>汇编指令</strong> 最后在不同平台下生成适配的 <strong>机器指令</strong>，最后运行</p><ul><li><strong>TurboFan 是一个编译器，可以将字节码编译为cpu可以直接执行的机器码</strong></li></ul><p> 由于<code>iginition</code>库对于 <strong>字节码</strong> 的处理事先转化为 <code>汇编指令</code>， 然后再转化为 <code>机器指令</code>，如果每次的解析过程都是这样子的话，对于一些高频函数的解析就会变的低效 所以就出现了 <strong>TurboFan</strong></p><p>TurboFan 库对于js代码的处理是对一些高频代码（函数）进行分析，如果发现出现频率高的话就会将其标记一个<strong>hot（热函数，也就是代表这个函数可能会被多次执行）</strong>，这样的话就可以将AST直接解析成 <strong>MaChineCode 优化的机器码</strong> 下次就可以直接使用优化后的机器码，可以大大提升效率</p><ul><li><strong>Deoptimization</strong></li></ul><p>这个其实可以理解为是取消优化的意思，也就是将 优化后的机器码 MachineCode 重新转化为 byteCode </p><p>为什么要有这个操作呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其实是因为由于js是一门动态语言， 不会对类型进行检测，所以可能会导致下面的情况发生</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">20</span>)<span class="comment">//30</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">33</span>, <span class="number">33</span>)<span class="comment">//66 </span></span><br><span class="line"><span class="title function_">sum</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>)<span class="comment">//&#x27;aaabbb&#x27;字符串拼接</span></span><br></pre></td></tr></table></figure><p><code>Deoptimezation</code>的作用就是对这种情况进行检测，同时对代码进行优化，如果监测到这种情况的话就会重新将 <code>MachineCode</code> 转化为 <code>bytecode</code> 然后变成汇编指令，最后再变成 机器指令</p><p>所以这也是 typeScript 出生的原因，由于有了类型限制，V8引擎对于js代码的解析会效率更高， <strong>《累死自己，爽死机器》~~~</strong></p><p><img src="https://wx4.sinaimg.cn/mw2000/0074C7s5gy1h7rnfuwnibj31cm0t47g5.jpg" alt="image-20221102180423847"></p><p>浏览器内核将源码交给v8引擎， Stream获取到代码之后会进行编码转换…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;浏览器工作原理&quot;&gt;&lt;a href=&quot;#浏览器工作原理&quot; class=&quot;headerlink&quot; title=&quot;浏览器工作原理&quot;&gt;&lt;/a&gt;浏览器工作原理&lt;/h3&gt;&lt;p&gt;![image-20221102152902371](&amp;#x2F;Users&amp;#x2F;tianca</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>协商缓存与强缓存</title>
    <link href="http://example.com/posts/1b970c35.html"/>
    <id>http://example.com/posts/1b970c35.html</id>
    <published>2022-11-05T01:10:45.798Z</published>
    <updated>2022-11-05T01:44:09.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协商缓存和强缓存"><a href="#协商缓存和强缓存" class="headerlink" title="协商缓存和强缓存"></a>协商缓存和强缓存</h1><p>还是首先来看一下，我们发送请求之后发生的东西，我们这次分析的就是在图中标红的部分</p><p>![image-20221105091011778](&#x2F;Users&#x2F;tiancaijiaoshou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221105091011778.png)</p><p>让我们来看看在这段时间内，具体发生了什么事情</p><ul><li>第一次请求的时候 发送的事情是这样子</li></ul><p>![image-20221105091943057](&#x2F;Users&#x2F;tiancaijiaoshou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221105091943057.png)</p><p>此时本地没有缓存的数据，所以会直接向服务端发送请求，请求到了资源之后在进行缓存处理</p><p>![image-20221105093308354](&#x2F;Users&#x2F;tiancaijiaoshou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221105093308354.png)</p><p>接下来我们将着重的分析每个参数在本次活动中的作用</p><ul><li><h4 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h4></li></ul><p>以微博登陆界面为例，发送请求后返回的数据请求头重会携带这样一个参数，这个参数用于判断每次请求的时间是否过期（timeout</p><p>![image-20221105093805656](&#x2F;Users&#x2F;tiancaijiaoshou&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221105093805656.png)</p><ul><li><h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4></li></ul><p>在http1.1的时候新出的标签，用来标示URL对象是否改变。这样可以应用于客户端的缓存：服务器产生ETag，并在HTTP响应头中将其传送到客户端，服务器用它来判断页面是否被修改过。</p><ul><li><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4></li></ul><p>这个标签主要用来判断请求资源中的最后一次修改时间遇上次请求的资源<code>最后一次修改时间</code>是否一致，</p><p>本文参考文献下</p><p><a href="https://juejin.cn/post/6844903736196726798#heading-1">浅解强缓存和协商缓存</a></p><p><a href="https://cloud.tencent.com/developer/section/1189956">https://cloud.tencent.com/</a></p><p><a href="https://zhuanlan.zhihu.com/p/162945656">ETag简介雨作用</a></p><p><a href="https://www.cnblogs.com/zh2000g/archive/2010/03/22/1692002.html">a1</a></p><p><a href="https://juejin.cn/post/6844903838768431118#heading-0">a2</a></p><p><a href="https://juejin.cn/post/7083178636852854792">缓存实操</a></p><p><a href="https://juejin.cn/post/6844903838768431118">面试必会</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;协商缓存和强缓存&quot;&gt;&lt;a href=&quot;#协商缓存和强缓存&quot; class=&quot;headerlink&quot; title=&quot;协商缓存和强缓存&quot;&gt;&lt;/a&gt;协商缓存和强缓存&lt;/h1&gt;&lt;p&gt;还是首先来看一下，我们发送请求之后发生的东西，我们这次分析的就是在图中标红的部分&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP连接过程</title>
    <link href="http://example.com/posts/8f59160.html"/>
    <id>http://example.com/posts/8f59160.html</id>
    <published>2022-11-04T07:51:58.517Z</published>
    <updated>2022-11-04T08:17:35.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-连接的过程"><a href="#TCP-连接的过程" class="headerlink" title="TCP 连接的过程"></a>TCP 连接的过程</h2><p>首先我们要先清楚 TCP 连接是在什么时间段发生的 当我们在浏览器地址输入栏输入了一段地址之后会有如下操作依次发生 ⬇️</p><p><img src="/../images/22:11/tcp1.jpeg" alt="image-20221104104303067"></p><p>从这张简略图可以看出来 建立 TCP 连接的时间段是在构建请求且缓存中不存在这一段域名之后产生的 其实 TCP 连接可以简单的概括为 <strong>三次握手、四次挥手</strong> 首先我们先来看一下 <code>TCP头部</code> 结构</p><h3 id="TCP-头部结构"><a href="#TCP-头部结构" class="headerlink" title="TCP 头部结构"></a>TCP 头部结构</h3><p><img src="/../images/22:11/tcp2.jpeg" alt="image-20221104105858250"></p><p>其中在<code>TCP连接</code>中我们最需要关注的几个地方就是 <strong>序列号、确认号还有标记位(SYN、FIN、ACK、RST…)</strong></p><ul><li><strong>序列号</strong>相当于是随机出来的一个 ID，为本次 TCP 连接建立建议一个标志，序列号可以用来<strong>解决网络包乱序的问题</strong></li><li><strong>确认号</strong>主要用来表示「接收端」告诉「发送端」对上一个数据包已经成功接收（确认号可以⽤来<strong>解决网络包丢失的问题</strong>）</li><li><strong>标记位</strong>主要就是用来表达各种意义，如 <code>SYN = 1</code> 时，表示<strong>希望创建连接</strong>。<code>ACK = 1</code>时，确认号<strong>字段有效</strong>。<code>FIN = 1</code>时，表示<strong>希望断开连接</strong>。<code>RST = 1</code> 时，表示 TCP<strong>连接出现异常</strong>，需要断开。</li></ul><h3 id="TCP-三次握手的全过程"><a href="#TCP-三次握手的全过程" class="headerlink" title="TCP 三次握手的全过程"></a>TCP 三次握手的全过程</h3><p><img src="/../images/22:11/tcp3.jpeg" alt="image-20221104112237199"></p><ul><li>一开始服务端与客户端都处于 <code>CLOSE</code> 状态</li><li>服务端主动监听一个端口，进入 <code>listen</code> 状态</li><li>客户端发送 SYN 包（表示希望建立 TCP 连接），其中 SYN 的值是随机生成的<strong>序列号</strong>，随机将 <strong>请求报文</strong> 发送给客户端，并且自己也进入了 <strong>SYN_SEND</strong> 状态</li><li>此时服务端接收到了来自客户端发送的 SYN 包 会返回一个 ACK 包和一个 SYN 包，其中 ACK 包是确认包，表示服务端已经接收到了来自客户端的请求，其值为 <code>Client_Num + 1</code>,<strong>SYN 包</strong> 的值则是客户端这边随机出来的序列号，同时将 <strong>ACK 和 SYN 的标记位置为 1</strong>，将报文发送到客户端，随机自己进入 <strong>SYN_RCVD</strong> 状态</li><li>此时客户端接收到了来自服务端的确认包，可以保证客户端已经接收到了他的请求，此时就需要再次发送一个<code>ACK</code> 确认包，告诉服务端自己已经接收到了请求，其值为 <code>server_num + 1</code> , 并且将 <strong>ACK 标记位置为 1</strong> 发送报文后自己进入 <strong>ESTABLISHED 状态</strong></li><li>服务端接收到了来自客户端发送的报文之后，随机也进入了 <strong>ESTABLISHED 状态</strong>，此时双方建立起了连接</li></ul><p><strong>以上就是 TCP 三次握手的过程</strong></p><h4 id="面经之为什么不能采用两次握手，一定要三次？？？"><a href="#面经之为什么不能采用两次握手，一定要三次？？？" class="headerlink" title="面经之为什么不能采用两次握手，一定要三次？？？"></a>面经之为什么不能采用两次握手，一定要三次？？？</h4><blockquote><p>这里我就用最简单的方式来告诉大家吧</p><ul><li><p>第一次握手：客户端向服务端发送了网络包，服务端接收到了。可以证明 ⬇️</p><ul><li><strong>服务端</strong>知道了<strong>客户端的发送能力和服务端的接受能力是没有问题了</strong></li></ul></li><li><p>第二次握手：服务端的发包，客户端接收到了，此时可以证明 ⬇️</p><ul><li><p><strong>服务端</strong>知道了<strong>客户端的发送能力和服务端的接受能力是没有问题了</strong></p></li><li><p><strong>客户端</strong>知道 <strong>服务端的接受能力和发送能力没问题，自己的接受能力和发送能力没问题</strong></p></li></ul></li></ul><p>但是此时的服务端不知道的是，自己发送的包客户端能不能接收到，也就是服务端无法确认自己的发送能力和客户端的接受能力是否正常 所以这个时候就需要 TCP 的第三次握手</p><ul><li>第三次握手：客户端向服务端发包，服务端接收到了<ul><li>此时的 <strong>服务端</strong> 就知道双方的发包能力和接受包的能力都是没问题的，也就建立起了 TCP 连接</li></ul></li></ul></blockquote><h4 id="面经之三次握手的过程中可以发送数据吗"><a href="#面经之三次握手的过程中可以发送数据吗" class="headerlink" title="面经之三次握手的过程中可以发送数据吗"></a>面经之三次握手的过程中可以发送数据吗</h4><blockquote><p>答案是可以的 第三次握手的时候，由于客户端已经知道双方的发包已经收包能力都是正常的，就可以正常的发送数据了</p></blockquote><h3 id="TCP-四次挥手的全过程"><a href="#TCP-四次挥手的全过程" class="headerlink" title="TCP 四次挥手的全过程"></a>TCP 四次挥手的全过程</h3><p>首先我们还是用图来表示一下这个过程 8⃣️</p><p><img src="/../images/22:11/tcp4.jpeg" alt="image-20221104153457431"></p><ul><li><p>一开始的时候，服务端和客户端仍处于 <strong><code>ESTABLISHED</code></strong> 状态</p></li><li><p>客户端首先想要断开连接，这时就会向服务端发送一个**<code>FIN</code>**报文，报文中有一个指定的序列号，表示想要断开链接，并且进入 <strong>FIN_SAIT_1</strong> 状态</p></li><li><p>此时服务端收到了由客户端发送来的<code>FIN</code>包之后，会先给客户端发送一个 <code>ACK</code> 报文，<code>报文的序列号为客户端的序列号值 + 1</code>，表示自己已经收到了，但是需要检查一下自己还有没有什么需要发送的资源，并且进入 <strong>CLOSE_WAIT</strong>状态</p></li><li><p>等到服务端检查完毕没有需要发送的资源之后，就会给客户端发送一个 FIN 包表示即将断开链接，并且进入 <strong>LAST_ACK</strong> 状态</p></li><li><p>客户端收到了 <strong>FIN</strong> 包之后，再次发送一个 <strong>ACK</strong> 报文，<code>报文的序列号为服务端的序列号值 + 1</code>，表示自己已经收到，随机进入 <strong>TIME_WAIT</strong> 状态，等待<code>2msl</code> 之后，就进入了 <strong>CLOSE</strong> 状态</p></li><li><p>服务端接收到了来自客户端发送的 <strong>ACK</strong> 包之后，也进入了 <strong>CLOSE</strong> 状态</p></li></ul><p>以上就是 TCP 四次挥手的全过程，你听明白了嘛～</p><h4 id="面经之为什么要有-TIME-WAIT-这个状态"><a href="#面经之为什么要有-TIME-WAIT-这个状态" class="headerlink" title="面经之为什么要有 TIME_WAIT 这个状态"></a>面经之为什么要有 TIME_WAIT 这个状态</h4><ul><li>确保服务端已经接收到了由客户端发送过去的 ACK 报文，如果没有收到 ACK 报文的话，服务端会再起发送一个 FIN 报文给客户端，因为 TIME_WAIT 的时间至少是一个报文的来回时间，一般会使用及时，时间到了客户端就进入 <strong>CLOSE</strong> 状态</li><li>确保网络中已经没有 <code>数据残缺</code> 了，避免这次 <code>TCP</code> 连接中的数据污染到下一次 TCP 连接</li></ul><h3 id="下面给出的-TCP-连接中状态的意义"><a href="#下面给出的-TCP-连接中状态的意义" class="headerlink" title="下面给出的 TCP 连接中状态的意义"></a>下面给出的 TCP 连接中状态的意义</h3><ul><li><strong>LISTEN</strong> – 侦听来自远方 TCP 端口的连接请求；</li><li><strong>SYN-SENT</strong> -在发送连接请求后等待匹配的连接请求；</li><li><strong>SYN-RECEIVED</strong> – 在收到和发送一个连接请求后等待对连接请求的确认；</li><li><strong>ESTABLISHED</strong>- 代表一个打开的连接，数据可以传送给用户；</li><li><strong>FIN-WAIT-1</strong> – 等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认；</li><li><strong>FIN-WAIT-2</strong> – 从远程 TCP 等待连接中断请求；</li><li><strong>CLOSE-WAIT</strong> – 等待从本地用户发来的连接中断请求；</li><li><strong>CLOSING</strong> -等待远程 TCP 对连接中断的确认；</li><li><strong>LAST-ACK</strong> – 等待原来发向远程 TCP 的连接中断请求的确认；</li><li><strong>TIME-WAIT</strong> -等待足够的时间以确保远程 TCP 接收到连接中断请求的确认；</li><li><strong>CLOSED</strong> – 没有任何连接状态；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP-连接的过程&quot;&gt;&lt;a href=&quot;#TCP-连接的过程&quot; class=&quot;headerlink&quot; title=&quot;TCP 连接的过程&quot;&gt;&lt;/a&gt;TCP 连接的过程&lt;/h2&gt;&lt;p&gt;首先我们要先清楚 TCP 连接是在什么时间段发生的 当我们在浏览器地址输入栏输入了一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/posts/4a17b156.html"/>
    <id>http://example.com/posts/4a17b156.html</id>
    <published>2022-11-01T02:19:38.104Z</published>
    <updated>2022-11-01T03:34:00.514Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
