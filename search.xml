<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP连接过程</title>
      <link href="/posts/8f59160.html"/>
      <url>/posts/8f59160.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP连接的过程"><a href="#TCP连接的过程" class="headerlink" title="TCP连接的过程"></a>TCP连接的过程</h2><p>首先我们要先清楚 TCP连接是在什么时间段发生的 当我们在浏览器地址输入栏输入了一段地址之后会有如下操作依次发生⬇️</p><p><img src="https://wx2.sinaimg.cn/mw2000/0074C7s5gy1h7t5d66rgfj30b40y877b.jpg" alt="image-20221104104303067"></p><p>从这张简略图可以看出来 建立TCP连接的时间段是在构建请求且缓存中不存在这一段域名之后产生的 其实 TCP 连接可以简单的概括为 <strong>三次握手、四次挥手</strong> 首先我们先来看一下 <code>TCP头部</code> 结构</p><h3 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h3><p><img src="https://wx4.sinaimg.cn/mw2000/0074C7s5gy1h7t5d6dmj4j30hk0h4wgq.jpg" alt="image-20221104105858250"></p><p>其中在<code>TCP连接</code>中我们最需要关注的几个地方就是 <strong>序列号、确认号还有标记位(SYN、FIN、ACK、RST…)</strong></p><ul><li><strong>序列号</strong>相当于是随机出来的一个ID，为本次TCP连接建立建议一个标志，序列号可以用来<strong>解决网络包乱序的问题</strong></li><li><strong>确认号</strong>主要用来表示「接收端」告诉「发送端」对上一个数据包已经成功接收（确认号可以⽤来<strong>解决网络包丢失的问题</strong>）</li><li><strong>标记位</strong>主要就是用来表达各种意义，如 <code>SYN = 1</code> 时，表示<strong>希望创建连接</strong>。<code>ACK = 1</code>时，确认号<strong>字段有效</strong>。<code>FIN = 1</code>时，表示<strong>希望断开连接</strong>。<code>RST = 1</code> 时，表示TCP<strong>连接出现异常</strong>，需要断开。</li></ul><h3 id="TCP三次握手的全过程"><a href="#TCP三次握手的全过程" class="headerlink" title="TCP三次握手的全过程"></a>TCP三次握手的全过程</h3><p><img src="https://wx3.sinaimg.cn/mw2000/0074C7s5gy1h7t5d6kddzj30s60m4q7r.jpg" alt="image-20221104112237199"></p><ul><li>一开始服务端与客户端都处于 <code>CLOSE</code> 状态</li><li>服务端主动监听一个端口，进入 <code>listen</code> 状态</li><li>客户端发送 SYN 包（表示希望建立 TCP 连接），其中 SYN 的值是随机生成的<strong>序列号</strong>，随机将 <strong>请求报文</strong> 发送给客户端，并且自己也进入了 <strong>SYN_SEND</strong> 状态</li><li>此时服务端接收到了来自客户端发送的SYN包 会返回一个 ACK 包和一个 SYN 包，其中ACK包是确认包，表示服务端已经接收到了来自客户端的请求，其值为 <code>Client_Num + 1</code>,<strong>SYN包</strong> 的值则是客户端这边随机出来的序列号，同时将 <strong>ACK 和 SYN 的标记位置为1</strong>，将报文发送到客户端，随机自己进入 <strong>SYN_RCVD</strong> 状态</li><li>此时客户端接收到了来自服务端的确认包，可以保证客户端已经接收到了他的请求，此时就需要再次发送一个<code>ACK</code> 确认包，告诉服务端自己已经接收到了请求，其值为 <code>server_num + 1</code> , 并且将 <strong>ACK标记位置为1</strong> 发送报文后自己进入 <strong>ESTABLISHED状态</strong></li><li>服务端接收到了来自客户端发送的报文之后，随机也进入了 <strong>ESTABLISHED状态</strong>，此时双方建立起了连接</li></ul><p><strong>以上就是TCP三次握手的过程</strong></p><h4 id="面经之为什么不能采用两次握手，一定要三次？？？"><a href="#面经之为什么不能采用两次握手，一定要三次？？？" class="headerlink" title="面经之为什么不能采用两次握手，一定要三次？？？"></a>面经之为什么不能采用两次握手，一定要三次？？？</h4><blockquote><p>这里我就用最简单的方式来告诉大家吧</p><ul><li><p>第一次握手：客户端向服务端发送了网络包，服务端接收到了。可以证明⬇️</p><ul><li><strong>服务端</strong>知道了<strong>客户端的发送能力和服务端的接受能力是没有问题了</strong></li></ul></li><li><p>第二次握手：服务端的发包，客户端接收到了，此时可以证明⬇️</p><ul><li><p><strong>服务端</strong>知道了<strong>客户端的发送能力和服务端的接受能力是没有问题了</strong></p></li><li><p><strong>客户端</strong>知道 <strong>服务端的接受能力和发送能力没问题，自己的接受能力和发送能力没问题</strong></p></li></ul></li></ul><p>但是此时的服务端不知道的是，自己发送的包客户端能不能接收到，也就是服务端无法确认自己的发送能力和客户端的接受能力是否正常 所以这个时候就需要 TCP 的第三次握手</p><ul><li>第三次握手：客户端向服务端发包，服务端接收到了<ul><li>此时的 <strong>服务端</strong> 就知道双方的发包能力和接受包的能力都是没问题的，也就建立起了TCP连接</li></ul></li></ul></blockquote><h4 id="面经之三次握手的过程中可以发送数据吗"><a href="#面经之三次握手的过程中可以发送数据吗" class="headerlink" title="面经之三次握手的过程中可以发送数据吗"></a>面经之三次握手的过程中可以发送数据吗</h4><blockquote><p>答案是可以的 第三次握手的时候，由于客户端已经知道双方的发包已经收包能力都是正常的，就可以正常的发送数据了</p></blockquote><h3 id="TCP四次挥手的全过程"><a href="#TCP四次挥手的全过程" class="headerlink" title="TCP四次挥手的全过程"></a>TCP四次挥手的全过程</h3><p>首先我们还是用图来表示一下这个过程8⃣️</p><p><img src="https://wx2.sinaimg.cn/mw2000/0074C7s5gy1h7t5d6t4nhj30x20vg10b.jpg" alt="image-20221104153457431"></p><ul><li><p>一开始的时候，服务端和客户端仍处于 <strong><code>ESTABLISHED</code></strong> 状态</p></li><li><p>客户端首先想要断开连接，这时就会向服务端发送一个**<code>FIN</code>**报文，报文中有一个指定的序列号，表示想要断开链接，并且进入 <strong>FIN_SAIT_1</strong> 状态</p></li><li><p>此时服务端收到了由客户端发送来的<code>FIN</code>包之后，会先给客户端发送一个 <code>ACK</code> 报文，<code>报文的序列号为客户端的序列号值 + 1</code>，表示自己已经收到了，但是需要检查一下自己还有没有什么需要发送的资源，并且进入 <strong>CLOSE_WAIT</strong>状态</p></li><li><p>等到服务端检查完毕没有需要发送的资源之后，就会给客户端发送一个 FIN 包表示即将断开链接，并且进入 <strong>LAST_ACK</strong> 状态</p></li><li><p>客户端收到了 <strong>FIN</strong> 包之后，再次发送一个 <strong>ACK</strong> 报文，<code>报文的序列号为服务端的序列号值 + 1</code>，表示自己已经收到，随机进入 <strong>TIME_WAIT</strong> 状态，等待<code>2msl</code> 之后，就进入了 <strong>CLOSE</strong> 状态</p></li><li><p>服务端接收到了来自客户端发送的 <strong>ACK</strong> 包之后，也进入了 <strong>CLOSE</strong> 状态</p></li></ul><p>以上就是TCP四次挥手的全过程，你听明白了嘛～ </p><h4 id="面经之为什么要有-TIME-WAIT-这个状态"><a href="#面经之为什么要有-TIME-WAIT-这个状态" class="headerlink" title="面经之为什么要有 TIME_WAIT 这个状态"></a>面经之为什么要有 TIME_WAIT 这个状态</h4><ul><li>确保服务端已经接收到了由客户端发送过去的 ACK 报文，如果没有收到ACK报文的话，服务端会再起发送一个 FIN 报文给客户端，因为 TIME_WAIT 的时间至少是一个报文的来回时间，一般会使用及时，时间到了客户端就进入 <strong>CLOSE</strong> 状态</li><li>确保网络中已经没有 <code>数据残缺</code> 了，避免这次 <code>TCP</code> 连接中的数据污染到下一次 TCP 连接</li></ul><h3 id="下面给出的TCP连接中状态的意义"><a href="#下面给出的TCP连接中状态的意义" class="headerlink" title="下面给出的TCP连接中状态的意义"></a>下面给出的TCP连接中状态的意义</h3><ul><li><strong>LISTEN</strong> – 侦听来自远方TCP端口的连接请求；</li><li><strong>SYN-SENT</strong> -在发送连接请求后等待匹配的连接请求；</li><li><strong>SYN-RECEIVED</strong> – 在收到和发送一个连接请求后等待对连接请求的确认；</li><li><strong>ESTABLISHED</strong>- 代表一个打开的连接，数据可以传送给用户；</li><li><strong>FIN-WAIT-1</strong> – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</li><li><strong>FIN-WAIT-2</strong> – 从远程TCP等待连接中断请求；</li><li><strong>CLOSE-WAIT</strong> – 等待从本地用户发来的连接中断请求；</li><li><strong>CLOSING</strong> -等待远程TCP对连接中断的确认；</li><li><strong>LAST-ACK</strong> – 等待原来发向远程TCP的连接中断请求的确认；</li><li><strong>TIME-WAIT</strong> -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</li><li><strong>CLOSED</strong> – 没有任何连接状态；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
